import xobjects as xo
import xtrack as xt

import numpy as np


class BeamBeam3D(xt.BeamElement):

    _xofields = {
        'q0': xo.Float64,

        # Angles used to move particles to the computation reference frame:
        'alpha': xo.Float64,   # Orientation of the crossing plane
        'phi': xo.Float64,     # Half crossing angle

        # Shifts used to move the particles to the computation reference frame:
        'ref_shift_x': xo.Float64,
        'ref_shift_px': xo.Float64,
        'ref_shift_y': xo.Float64,
        'ref_shift_py': xo.Float64,
        'ref_shift_zeta': xo.Float64,
        'ref_shift_delta_shift': xo.Float64,

        # Number of slices (self and other)
        'num_slices_self': xo.Int64,
        'num_slices_other': xo.Int64,

        #### Slice self parameters
        # Binning
        'slices_self_z_star_center': xo.Float64[:],
        'slices_self_z_star_width': xo.Float64[:],
        # Binning
        'slices_other_z_star_center': xo.Float64[:],
        'slices_other_z_star_width': xo.Float64[:],
        # Intensity
        'slices_self_num_particles': xo.Float64[:],
        # First order momenta in the computation reference frame (star):
        'slices_self_x_star': xo.Float64[:],
        'slices_self_px_star': xo.Float64[:],
        'slices_self_y_star': xo.Float64[:],
        'slices_self_py_star': xo.Float64[:],
        # Second order momenta in the computation reference frame (star):
        'slices_self_Sigma_11_star': xo.Float64,
        'slices_self_Sigma_12_star': xo.Float64,
        'slices_self_Sigma_13_star': xo.Float64,
        'slices_self_Sigma_14_star': xo.Float64,
        'slices_self_Sigma_22_star': xo.Float64,
        'slices_self_Sigma_23_star': xo.Float64,
        'slices_self_Sigma_24_star': xo.Float64,
        'slices_self_Sigma_33_star': xo.Float64,
        'slices_self_Sigma_34_star': xo.Float64,
        'slices_self_Sigma_44_star': xo.Float64,

        #### Slice other parameters
        # Binning
        'slices_other_z_star_center': xo.Float64[:],
        'slices_other_z_star_width': xo.Float64[:],
        # Binning
        'slices_other_z_star_center': xo.Float64[:],
        'slices_other_z_star_width': xo.Float64[:],
        # Intensity
        'slices_other_num_particles': xo.Float64[:],
        # First order momenta in the computation reference frame (star):
        'slices_other_x_star': xo.Float64[:],
        'slices_other_px_star': xo.Float64[:],
        'slices_other_y_star': xo.Float64[:],
        'slices_other_py_star': xo.Float64[:],
        # Second order momenta in the computation reference frame (star):
        'slices_other_Sigma_11_star': xo.Float64,
        'slices_other_Sigma_12_star': xo.Float64,
        'slices_other_Sigma_13_star': xo.Float64,
        'slices_other_Sigma_14_star': xo.Float64,
        'slices_other_Sigma_22_star': xo.Float64,
        'slices_other_Sigma_23_star': xo.Float64,
        'slices_other_Sigma_24_star': xo.Float64,
        'slices_other_Sigma_33_star': xo.Float64,
        'slices_other_Sigma_34_star': xo.Float64,
        'slices_other_Sigma_44_star': xo.Float64,

        #### Kick  after the computation
        #### (e.g. to artificially remove dipolar effects)
        'subtract_x': xo.Float64,
        'subtract_px': xo.Float64,
        'subtract_y': xo.Float64,
        'subtract_py': xo.Float64,
        'subtract_zeta': xo.Float64,
        'subtract_delta': xo.Float64,

        #### Tolerances for special cases
        'min_sigma_diff': xo.Float64,
        'threshold_singular': xo.Float64,
    }

    # Data available only in python (to be filled properly by the __init__ method)
    slicer = None
    element_name = 'bb_beam1_at_IP1'
    collision_schedule = {
        'beam1_bunch1': 'beam2_bunch1',
        'beam1_bunch2': 'beam2_bunch2',
        'beam1_bunch3': 'beam2_bunch3',
    }
    pipeline_manager = None

    def track(self, particles): # For collective mode

        # If not collected call autogenerated method
        if not(self.iscollective):
            super().track(particles)

        if self.iscollective:
            assert isinstance(self._buffer.context, xo.ContextCpu), (
                'Still to be generalized to run on GPU')

            assert particles.name in self.collision_schedule.keys()

        #### Move particles to the computation reference frame

        # Shift
        particles.x += self.ref_shift_x
        particles.px += self.ref_shift_px
        particles.y += self.ref_shift_y
        particles.py += self.ref_shift_py
        particles.zeta += self.ref_shift_zeta
        particles.delta += self.ref_shift_delta_shift

        # Rotate and boost
        self._boost_particles(particles) # could be autogenerated (with some generalization in base_element.py)

        # Slice particles
        self.slice_index = self._buffer.context.zeros(
                                    shape=particles.x.shape, dtype=np.float64)
        self.slicer.compute_slice_index(particles, self.slice_index)

        # Kick
        for i_step in range(self.num_slices_self + self.num_slices_other):

            self._sychrobeam_kick(particles=particles, slice_index=self.slice_index,
                                  i_step=i_step)









