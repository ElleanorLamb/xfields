import xobjects as xo
import xtrack as xt

from xtrack.pipeline import PipelineStatus

import numpy as np


class BeamBeam3D(xt.BeamElement):

    _xofields = {
        'q0': xo.Float64,

        # Angles used to move particles to the computation reference frame:
        'alpha': xo.Float64,   # Orientation of the crossing plane
        'phi': xo.Float64,     # Half crossing angle

        # Shifts used to move the particles to the computation reference frame:
        'ref_shift_x': xo.Float64,
        'ref_shift_px': xo.Float64,
        'ref_shift_y': xo.Float64,
        'ref_shift_py': xo.Float64,
        'ref_shift_zeta': xo.Float64,
        'ref_shift_delta_shift': xo.Float64,

        # Number of slices (self and other)
        'num_slices_self': xo.Int64,
        'num_slices_other': xo.Int64,

        #### Slice self parameters
        # Binning
        'slices_self_z_star_center': xo.Float64[:],
        'slices_self_z_star_width': xo.Float64[:],
        # Binning
        'slices_other_z_star_center': xo.Float64[:],
        'slices_other_z_star_width': xo.Float64[:],
        # Intensity
        'slices_self_num_particles': xo.Float64[:],
        # First order momenta in the computation reference frame (star):
        'slices_self_x_star': xo.Float64[:],
        'slices_self_px_star': xo.Float64[:],
        'slices_self_y_star': xo.Float64[:],
        'slices_self_py_star': xo.Float64[:],
        # Second order momenta in the computation reference frame (star):
        'slices_self_Sigma_11_star': xo.Float64,
        'slices_self_Sigma_12_star': xo.Float64,
        'slices_self_Sigma_13_star': xo.Float64,
        'slices_self_Sigma_14_star': xo.Float64,
        'slices_self_Sigma_22_star': xo.Float64,
        'slices_self_Sigma_23_star': xo.Float64,
        'slices_self_Sigma_24_star': xo.Float64,
        'slices_self_Sigma_33_star': xo.Float64,
        'slices_self_Sigma_34_star': xo.Float64,
        'slices_self_Sigma_44_star': xo.Float64,

        #### Slice other parameters
        # Binning
        'slices_other_z_star_center': xo.Float64[:],
        'slices_other_z_star_width': xo.Float64[:],
        # Binning
        'slices_other_z_star_center': xo.Float64[:],
        'slices_other_z_star_width': xo.Float64[:],
        # Intensity
        'slices_other_num_particles': xo.Float64[:],
        # First order momenta in the computation reference frame (star):
        'slices_other_x_star': xo.Float64[:],
        'slices_other_px_star': xo.Float64[:],
        'slices_other_y_star': xo.Float64[:],
        'slices_other_py_star': xo.Float64[:],
        # Second order momenta in the computation reference frame (star):
        'slices_other_Sigma_11_star': xo.Float64,
        'slices_other_Sigma_12_star': xo.Float64,
        'slices_other_Sigma_13_star': xo.Float64,
        'slices_other_Sigma_14_star': xo.Float64,
        'slices_other_Sigma_22_star': xo.Float64,
        'slices_other_Sigma_23_star': xo.Float64,
        'slices_other_Sigma_24_star': xo.Float64,
        'slices_other_Sigma_33_star': xo.Float64,
        'slices_other_Sigma_34_star': xo.Float64,
        'slices_other_Sigma_44_star': xo.Float64,

        #### Kick  after the computation
        #### (e.g. to artificially remove dipolar effects)
        'subtract_x': xo.Float64,
        'subtract_px': xo.Float64,
        'subtract_y': xo.Float64,
        'subtract_py': xo.Float64,
        'subtract_zeta': xo.Float64,
        'subtract_delta': xo.Float64,

        #### Tolerances for special cases
        'min_sigma_diff': xo.Float64,
        'threshold_singular': xo.Float64,
    }

    # TODO: Data available only in python (to be filled properly by the __init__ method)
    slicer = None
    element_name = 'bb_beam1_at_IP1'
    partner_element_name = 'bb_beam2_at_IP1'
    collision_schedule = {
        'beam1_bunch1': 'beam2_bunch1',
        'beam1_bunch2': 'beam2_bunch2',
        'beam1_bunch3': 'beam2_bunch3',
    }
    pipeline_manager = None
    i_step = 0

    def track(self, particles): # For collective mode

        # If not collected call autogenerated method
        if not(self.iscollective):
            super().track(particles)

        if self.iscollective:
            assert isinstance(self._buffer.context, xo.ContextCpu), (
                'Still to be generalized to run on GPU')
            assert self.collision_schedule is not None
            assert self.pipeline_manager is not None
            assert self.i_step == 0
            assert self._working_on_bunch is None # Not occupied by a bunch
            assert particles.name in self.collision_schedule.keys()


        assert self.slide_index is None # The previous bunch interaction has been completed

        self._working_on_bunch = particles.name

        # Move particles to the computation reference frame
        self._change_ref_frame(particles)

        # Slice the particles
        self._slice_particles(particles)

        # Apply the bb kicks (puts the simulation on hold if waiting for message)
        ret = self._finalize_computation()

        # Ret is None if done, esle it is a PipelineStatus
        return ret

    def _change_ref_frame(self, particles):
        # Shift
        particles.x += self.ref_shift_x
        particles.px += self.ref_shift_px
        particles.y += self.ref_shift_y
        particles.py += self.ref_shift_py
        particles.zeta += self.ref_shift_zeta
        particles.delta += self.ref_shift_delta_shift

        # Rotate and boost
        self._boost_particles(particles) # could be autogenerated (with some generalization in base_element.py)

    def _slice_particles(self, particles):
        self.slicer.slice_particles(particles)
        self.slice_index = self._buffer.context.zeros(
                                    shape=particles.x.shape, dtype=np.float64)
        self.slicer.compute_slice_index(particles, self.slice_index)

    def _apply_bb_kicks_and_restore_ref_frame(self, particles):

        while True:
            # Compute momenta
            momenta_self = self.compute_slice_momenta(particles, self.slice_index)

            # Send momenta (I invent a bit for now...)
            self.pipeline_manager.send_data(momenta_self,
                destination_for_particles=self.collision_schedule[particles.name] # Should we put the collision schedule in pipeline_manager?
                tag_from_sting=f'{self.name}__{particles.name}__{i_step}')

            # Receive momenta (I invent a bit for now...)
            data_received = self.pipeline_manager.receive_data(
                destination_for_particles=self.collision_schedule[particles.name]
                tag_from_sting=f'{self.partner_element_name}__{self.collision_schedule[particles.name]}__{i_step}')

            if data_received == 'not_ready':
                return PipelineStatus(on_hold=True)
            else:
                self.update_from_received_data(data_received) # Method to be written

            self._sychrobeam_kick(particles=particles, slice_index=self.slice_index,
                                  i_step=self.i_step)

            self.i_step += 1
            if self.i_step == self.num_slices_self + self.num_slices_other:
                self.i_step = 0
                self._working_on_bunch = None
                break

        #### Move particles back from the computation reference frame and subtract user-defined kicks

        # Rotate and boost back
        self._anti_boost_particles(particles) # could be autogenerated (with some generalization in base_element.py)

        # Shift back and subtract user-defined kicks
        particles.x -= (self.ref_shift_x + self.subtract_x)
        particles.px -= (self.ref_shift_px + self.subtract_px)
        particles.y -= (self.ref_shift_y + self.subtract_y)
        particles.py -= (self.ref_shift_py + self.subtract_py)
        particles.zeta -= (self.ref_shift_zeta + self.subtract_zeta)
        particles.delta -= (self.ref_shift_delta_shift + self.subtract_delta)

        return None











